# linux-driver-demo
linux驱动程序开发示例。

## 设备和驱动
驱动是硬件物理接口的封装。   
以键盘工作过程为例：
+ 与键盘相关的芯片有两个，键盘编码器i8048和键盘控制器i8042。芯片内烧录有程序，芯片本身就是一个小的处理器，内部有自己的处理器，有自己的Ram，有自己的寄存器等。
+ 键盘编码器i8048位于键盘，主要是监测键的按下和弹起，然后将两种状态编码，发送给键盘控制器。
+ 键盘控制器i8042不在键盘，在计算机主板上。主要接收键盘编码器发来的键盘扫描码，然后触发中断通知CPU来读取扫描码。
+ 键盘驱动直接读写键盘控制器i8042芯片，通过i8042芯片间接的向键盘中的i8048发命令。

## 从驱动到设备模型再到设备树
在引入设备驱动模型之前，设备和驱动没有分离。设备的信息硬编码在驱动代码中，给驱动程序造成极大的限制。如果硬件有改动，要修改驱动代码，驱动的通用性将会非常的差。

在引入设备树之前，代码中充斥大量的平台设备Platform Device代码，而这些代码大多数都是重复的。之前的内核移植工作有很大一部分工作就是在复制一份代码，并修改代码中和目标板中与特定硬件相关的平台设备信息。设备树替代了平台设备，实现驱动代码与设备硬件信息相分离。

## 驱动类型
### 按设备类型划分
主要分为三类：块驱动b，字符驱动c，网络设备ifconfig   
+ 字符设备：设备对数据的处理按照字节流的形式进行。例如串口、键盘、触摸屏、摄像头等，应用程序能使用系统IO函数open、write、read等来访问。
+ 块设备：设备的处理按照若干个块来进行。主要是面向于存储类的设备如nand flash、SD卡、U盘、硬盘。
+ 网络设备：在/dev没有设备文件，主要作用是进行网络的数据收发。
+ 字符设备和块设备的主要区别：在对字符设备发出读/写请求时，会立即发生硬件I/O。而块设备则利用一块系统内存作缓冲区。
### 按运行环境划分
分为两类：用户态驱动和内核态驱动
+ 用户态驱动：设备驱动程序可以完全地或部分地运行在用户态，驱动不需要到内核进行注册。对应用提供接口，再通过系统调用进入内核态，使用内核态驱动提供的服务。主要应用场景在芯片，驱动主要做控制芯片用途；以及加速器，功能独立，无需内核调度。用户态驱动最大的好处就是代码灵活，可以自己定自己的代码架构。缺点是内核无法识别设备、难处理中断、无法使用内核服务。
+ 内核态驱动：一般的linux程序驱动都属于此类。   

还有的既可以运行在用户态，也可以运行在内核态。

## 驱动开发
### 跨平台开发
使用vs在本地windows环境开发linux程序驱动
+ 头文件依赖：下载linux内核源码，在项目属性里添加附加包含目录。
+ 远程调试：安装VC_Linux.exe插件，创建跨平台项目，配置远程linux环境连接。
 
参考[跨平台开放环境搭建](https://www.likecs.com/show-204099668.html)

### 内核态
和普通linux应用程序开发不同
+ 函数：在内核态下，不能使用用户态的函数。如malloc()和free()函数申请和释放内存，需改为使用include/linux/kernel.h文件中声明的kmalloc()和kfree()

+ 内存：由于内核态和用户态使用不同的内存定义，所以二者之间不能直接访问对方的内存。而应该使用Linux中的用户和内核态内存交互函数copy_from_user和copy_to_user，声明在include/asm/uaccess.h中

+ 输出：不能使用用户态C库函数中的printf()函数输出信息，而只能使用printk()。但是，内核中printk()函数的设计目的并不是为了和用户交流，它实际上是内核的一种日志机制，用来记录下日志信息或者给出警告提示。

### 编译
+ gcc编译：内核模块的编译需要给gcc指示-D__KERNEL__和-DMODULE -DLINUX参数。-I选项跟着Linux内核源代码中Include目录的路径。例gcc -D__KERNEL__ -DMODULE -DLINUX -I /usr/local/src/linux2.4/include -c -o hello.o hello.c
+ kbuild编译：即kernel build，用于编译内核文件，对Makefile做了功能扩充。

### 驱动测试
```
1、编译驱动：make
2、加载驱动：insmod xxx.ko
3、创建节点（程序自动创建时可跳过）：mknod /dev/xxx c xxx 0
4、编译上层应用并执行，会调用驱动
5、卸载驱动：rmmod xxx

其他指令
1、打印内核信息：dmesg
```

## 设备驱动模型
### sysfs虚拟文件系统
模型体现在sysfs虚拟文件系统，路径是/sys，目录并不是存储在硬盘上的真实的文件系统，只有在系统启动之后才会建起来。
#### /sys和/proc区别
+ /proc是内存中有关系统进程的实时信息。
+ /sys是有关系统内核以及驱动的实时信息。

#### /sys目录结构
#### 平台设备和驱动
+ 对于usb设备、i2c设备、pci设备、spi设备等，他们与cpu的通信都是直接挂在相应的总线下面。
+ 有些设备通过各自的设备控制器，直接和CPU连接，不属于传统意义上的总线连接。但设备模型应该具备普适性，因此Linux设备驱动模型为了保持设备驱动的统一性就虚构了一条Platform Bus平台总线，供这些设备挂靠。

### 模型要素
+ 总线bus：总线是CPU和一个或多个设备之间信息交互的通道。所有的设备都应连接到总线上。设备通过总线去找对应的驱动，驱动通过总线去找合适的设备。
+ 设备device：抽象系统中所有的硬件设备，描述它的名字、属性、从属的Bus、从属的Class等信息。
+ 驱动device driver：用driver抽象硬件设备的驱动程序，它包含设备初始化、电源管理相关的接口实现。而Linux内核中的驱动开发，基本都围绕该抽象进行，实现所规定的接口函数。
+ 类class：集合具有相似功能或属性的设备，可以抽象出一套可以在多个设备之间共用的数据结构和接口函数。从属于相同Class的设备的驱动程序，就不再需要重复定义这些公共资源，直接从Class中继承即可，减少驱动开发过程中的重复劳动，降低工作量。

### 模型要素关系
+ 注册：device和driver都按类型注册到bus下。
+ 匹配：device和driver通过bus提供的match方法来匹配（使用设备id、name名称等）。
+ 回调：driver匹配到device后，调用driver的probe接口驱动device。
+ 对应：一个driver可以驱动多个相同的设备或者不同的device。

## 设备驱动和（总线）驱动模型区别
以字符设备驱动和usb字符设备驱动模型为例。   
**设备驱动模型侧重于内核对总线、设备和驱动的管理，并向应用层暴露这些管理的信息，而字符设备驱动则侧重于设备驱动的功能实现。**
+ 字符设备驱动使用cdev对象和register_chrdev函数创建设备；驱动模型使用device对象和device_register函数创建设备。
+ 字符设备驱动的核心框架跟设备模型、平台设备驱动没有直接关系，不用他们也一样能够正常工作。如果没有设备模型，应用层很难知晓驱动和设备的关系，因为字符设备驱动并没有提供这些信息，对于设备驱动的管理者而言会非常麻烦。
+ 字符设备驱动的file_operations接口中没有电源管理方面的接口。设备驱动模型提供统一的电源管理机制。对于操作系统来说，电源功耗管理必不可少。
+ 在设备驱动开发中使用device_create函数创建对象，需先自动创建设备节点。在驱动模型中使用device_register函数创建对象，函数里包含有自动创建设备节点。

## 设备树
设备树是一个描述硬件的数据结构。只是提供了一种语言，将硬件配置从Linux内核源码中提取出来。整个设备树包含DTC（device tree compiler），DTS（device tree source）和DTB（device tree blob）。
+ DTS：是一种ASCII文本格式的设备树描述。
+ DTC：是将.dts编译为.dtb的工具，相当于gcc。
+ DTB：文件是.dts被DTC编译后的二进制格式的设备树文件，它由Linux内核解析，也可以被bootloader进行解析。   

驱动可以读取设备树下匹配的设备配置参数。

## 其他
### 内核配置和编译
+ menuconfig：支持配置内核的图形化界面。
+ Kconfig：生成menuconfig界面的脚本语言