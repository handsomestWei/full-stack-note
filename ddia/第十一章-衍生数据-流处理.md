# 衍生数据-流处理
+ 流的来源（用户活动事件，传感器和写入数据库）
+ 流的传输（直接通过消息传送，通过消息代理，通过事件日志）
+ 用流做什么

## 传递事件流

### 轮询
```
文件或数据库就足以连接生产者和消费者。
生产者：将其生成的每个事件写入数据存储。
消费者：定期轮询数据存储，检查自上次运行以来新出现的事件。
```
```
缺点：相当于批处理。开销大，不实时。
```

### 数据库触发器
```
功能有限。
```

### 消息系统

#### 生产者发送消息的速度 > 消费者能够处理的速度
```
解决方案：
1、丢弃。
2、放入缓冲队列。被缓存在内存，需要落盘，避免系统突然崩溃，磁盘访问影响消息传递性能。
3、背压。流量控制，使生产者被阻塞，以免其发送更多的消息。
```

#### 无代理
生产者和消费者之间的直接网络通信，而不通过中间节点。
```
1、无代理的消息库：如ZeroMQ通过TCP或IP多播实现发布/订阅消息传递。
2、webhooks思想：消费者在网络上公开了服务，生产者可以直接发送HTTP或RPC请求将消息推送给使用者。一种服务的回调URL被注册到另一个服务中，并且每当事件发生时都会向该URL发出请求。
```
```
缺点：容错有限，容易丢消息，需假设生产者和消费者始终在线。
```

#### 消息代理
```
实质是一种针对处理消息流而优化的数据库。
```

##### 消息代理和数据库的区别
```
代理不适合长期的数据存储：数据库通常保留数据直至显式删除，而大多数消息代理在消息成功递送给消费者时会自动删除消息。
工作集相当小：队列很短，因为很快能删除消息。
数据查询方式：数据库通常支持二级索引和各种搜索数据的方式，而消息代理通常支持按照某种模式匹配主题。
数据：数据库结果通常基于某个时间点的数据快照，数据更新后客户端不会发现其先前结果现已过期。但消息代理当数据发生变化时（即新消息可用时）会通知客户端。
```

##### 扇出
```
每条消息都被传递给所有消费者。对应流处理中的概念：批处理中多个不同批处理作业读取同一份输入文件。
```

##### 消息乱序
```
负载均衡模式，消息被视为消费失败后，被代理重试投递到其他节点，会插入打乱该节点的消息接收，若消息有顺序的因果关系，会出现消费乱序。
```

##### AMQP/JMS风格的消息代理
```
代理将单条消息分配给消费者，消费者在成功处理单条消息后确认消息。消息被确认后从代理中删除。
适合作为一种异步形式的RPC
消息处理的确切顺序并不重要，而且消息在处理完之后，不需要回头重新读取旧消息。
```

##### 基于日志的消息代理
```
从数据库中获取灵感，既有数据库的持久存储方式，又有消息传递的低延迟通知。

短暂消息传递的思维：即使是将消息持久地写入磁盘的消息代理，在送达给消费者之后也会很快删除消息。收到消息是具有破坏性的，因为确认可能导致消息从代理中被删除，因此你不能期望再次运行同一个消费者能得到相同的结果。
数据库和文件系统：至少在某人显式删除前，通常写入数据库或文件的所有内容都要被永久记录下来。
批处理：可以反复运行，不用担心损坏输入（因为输入是只读的）。
```
```
如果你将新的消费者添加到消息系统，通常只能接收到消费者注册之后开始发送的消息。先前的任何消息都随风而逝，一去不复返。作为对比，你可以随时为文件和数据库添加新的客户端，且能读取任意久远的数据（只要应用没有显式覆盖或删除这些数据）
```

###### 使用日志进行消息存储
```
基于日志的方法天然支持扇出式消息传递，因为多个消费者可以独立读取日志，而不会相互影响。
```

###### 消费者偏移量
```
偏移量与数据库复制中的日志序列号非常相似。消息代理的表现得像一个主库，而消费者就像一个从库。
```

###### 磁盘空间使用
```
只追加写入日志，则磁盘空间终究会耗尽。为了回收磁盘空间，日志实际上被分割成段，并不时地将旧段删除或移动到归档存储。
可以在磁盘上使用循环缓冲区或环形缓冲区。
```

###### 重播旧信息
```
除了消费者的任何输出之外，处理的唯一副作用是消费者偏移量的前进。偏移量是在消费者的控制之下，可以很容易地操纵：消费者可以用昨天的偏移量跑一个消费者副本，并将输出写到不同的位置，以便重新处理最近一天的消息。可以使用各种不同的处理代码重复任意次。更像批处理，其中衍生数据通过可重复的转换过程与输入数据显式分离。
```

## 流与数据库
```
复制日志是数据库写入事件的流。
```

### 系统间数据同步
#### ETL
```
周期性的完整数据库转储过于缓慢。
```
#### dual write
```
双写。应用代码在数据变更时明确写入每个系统：例如，首先写入数据库，更新搜索索引，然后使缓存项失效。

引发的问题：
1、并发：多客户端同时写的竞争。
2、容错：其中一个写入可能会失败，而另一个成功。需要保证原子性。
```
#### CDC 
```
change data capture变更数据捕获。变更流，其他衍生数据系统只是变更流的消费者（日志消费者）。
```
```
变更数据捕获使得一个数据库成为领导者（被捕获变化的数据库），并将其他组件变为追随者。
```
##### 初始快照
```
重建数据库时
1、如果有全部的日志，可以重放日志。
2、但日志太大容易被截断，一般选取某个时间点快照，再同步时间点后的最近日志，进行追赶。
```
##### 日志压缩
```
只保留最新的键值。
允许消息代理被当成持久性存储使用，而不仅仅是用于临时消息。
重建数据库时读取，而无需从CDC源数据库取一个快照。
```

### 事件溯源
```
数据同步的追赶和DDD的事件溯源Event Sourcing有些类似。当查询时，要重新得到该对象的最新状态，只要先创建一个空的对象，然后将和该对象相关的所有事件按照事件发生先后顺序从先到后再全部应用一遍即可还原得到该对象的最新状态。
```

### 不可变事件
```
包含了比当前状态更多的信息。不删除或更改错误的数据，而是添加一条记录以补偿错误。
通过从不变的事件日志中分离出可变的状态，你可以针对不同的读取方式，从相同的事件日志中衍生出几种不同的表现形式。效果就像一个流的多个消费者一样。有点像DDD的CQRS命令查询责任分离。
```
```
不变性的限制:
真正删除数据是非常非常困难，副本可能存在于很多地方。删除更多的是“使取回数据更困难”，而不是“使取回数据不可能”。实际上是想改写历史，并假装数据从一开始就没有写入。
```

## 流处理
```
流不会结束。
排序对无界数据集没有意义。
容错机制改变：对于已经运行了几分钟的批处理作业，可以简单地从头开始重启失败任务，但是对于已经运行数年的流作业，重启后从头开始跑可能并不是一个可行的选项。
```

### 流处理的应用
#### CEP
```
复合事件处理（complex, event processing）
CEP引擎反转了角色：查询是长期存储的，来自输入流的事件不断流过它们，搜索匹配事件模式的查询。
Flink CEP与Flink DataStream对比：
1、CEP是为了找到数据的规律及关系
2、DataStream是对数据的清洗及过滤
```

#### 流分析
```
CEP与流分析的区别：分析往往对找出特定事件序列并不关心，而更关注大量事件上的聚合与统计指标。
```

#### 维护物化视图

#### 在流上搜索
```
和CEP类似
```

#### 消息传递和RPC
```
消息传递系统可以作为RPC的替代方案。
Actor模型不是流处理组件：
1、Actor框架主要是管理模块通信的并发和分布式执行的一种机制，而流处理主要是一种数据管理技术。
2、Actor之间的交流往往是短暂的，一对一的；而事件日志则是持久的，多订阅者的。
3、Actor可以以任意方式进行通信（允许包括循环的请求/响应），但流处理通常配置在无环流水线中，其中每个流都是一个特定作业的输出。
```

## 流式连接
```
批处理：作业通过键来连接数据集。
流连接：流-流连接，流-表连接，表-表连接
```

### 连接的时间依赖性
```
维度表的值也不是一成不变。缓慢变化的维度（slowly changing dimension, SCD）
```


## 容错
```
微批量
将流分解成小块，并像微型批处理一样处理每个块。被用于Spark Streaming，对性能妥协的结果：较小的批次会导致更大的调度与协调开销，而较大的批次意味着流处理器结果可见之前的延迟要更长。
```
```
存档点
定期生成状态的滚动存档点并将其写入持久存储。 Apache Flink使用。如果流算子崩溃，它可以从最近的存档点重启，并丢弃从最近检查点到崩溃之间的所有输出。
```