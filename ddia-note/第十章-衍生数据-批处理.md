# 衍生数据-批处理
输入数据是有界的，作业有完成之日。

## 系统分类
```
服务（在线系统）：迅速响应。
批处理系统（离线系统）：定期运行，每次运行需要一段时间。
流处理系统（准实时系统）：发生后不久就会对事件进行操作。
```

## MapReduce

### 与Unix工具区别
```
Unix工具使用stdin和stdout作为输入和输出，只能在一台机器上运行。
MapReduce作业在分布式文件系统上读写文件。
```

### 将计算放在数据附近原则
```
存算一体，在存储输入文件副本的机器上运行Mapper，节省通过网络复制输入文件的开销。
```

### 回调
```
MapReduce是围绕着回调函数的概念建立的：对于每条记录或者一组记录，调用一个用户定义的函数（Mapper或Reducer）
```

### shuffle混洗流程
```
1、当Mapper读取完输入文件，并写完排序后的输出文件。
2、MapReduce调度器就会通知Reducer可以从该Mapper开始获取输出文件。
3、Reducer连接到每个Mapper，并下载自己相应分区的有序键值对文件。按Reducer分区，排序，从Mapper向Reducer复制分区数据.
```

### Reducer端连接倾斜
```
现象:
单个键关联的大量数据，某个Reducer处理更多的记录。
```
```
解决方法：算法补偿。
1、显式指定热键，或运行抽样作业来确定热键。
2、将热键数据随机分发到其他Reducer
```

### Map端连接优化
```
例如：双流分别做Map再Reduce，选择不同的连接策略优化。
问题：Mapper扮演着预处理输入数据的角色。排序，复制至Reducer，以及合并Reducer输入，所有这些操作可能开销巨大。当数据通过MapReduce 阶段时，数据可能需要落盘好几次。
解决方案：将Reducer的部分处理前移到Mapper里实现。
```
#### 广播散列连接
```
场景：大数据集与小数据集连接。小数据集足够小，可以将其全部加载到每个Mapper的内存哈希表中（较小输入实际上“广播”到较大数据的所有分区上）。
```

#### 分区散列连接
```
Map端连接的输入，双流已经按相同的方式进行分区。还可以有基于相同的键进行排序。
```

### 物化中间状态
```
将中间状态写入文件的过程称为物化。
缺点：这些中间状态的临时数据，存储在分布式文件系统中，意味着这些文件被复制到多个节点，占用空间。
优点：容错，子任务执行失败，可以在另一台机器上重新启动，并从文件系统重新读取相同的输入，因为中间数据被持久化，不用重新运行全量任务。
```
```
MapReduce就像是将每个命令的输出写入临时文件，而数据流引擎看起来更像是Unix管道。尤其是Flink是基于管道执行的思想而建立的：将算子的输出增量地传递给其他算子，不待输入完成便开始处理。
```

### 数据流引擎
```
MapReduce的变种优化，不需要严格扮演交织的Map与Reduce的角色。
添加了自己的管道式数据传输机制，以避免将中间状态物化至分布式文件系统。更多地将中间状态保存在内存中，更少地物化中间状态，这意味着如果节点发生故障，则需要重算更多的数据。因此使用确定性算子减少需要重算的数据量。
```
```
算子：提供函数，连接输入输出，是Map和Reduce的泛化。
```

## 批处理的目的
与用于分析目的的OLAP SQL查询不同
```
1、全文搜索时动态创建索引。
2、构建机器学习系统如分类器，输出为键值存储。不建议连接存入数据库避免副作用。可以写入数据库存储文件，被其他数据库程序如HBase加载。
```

## 批处理上下文中的图
```
TODO：看不懂，等看懂了再回来补。
```

## 与分布式数据库的对比

### 存储多样性
```
 数据库要求根据特定的模型（例如关系或文档）来构造数据，而分布式文件系统中的文件只是字节序列，可以使用任何数据模型和编码来编写。
```

### 原始数据更好
```
 事务处理系统中的数据以某种原始形式转储到分布式文件系统中，然后编写MapReduce作业来清理数据，将其转换为关系形式，并将其导入MPP数据仓库以进行分析。数据建模仍然在进行，但它在一个单独的步骤中进行，与数据收集相解耦。
```

### 处理模型多样性
```
并非所有类型的处理都可以合理地表达为SQL查询，可以使用MapReduce建立一个SQL查询执行引擎。
批处理框架看起来越来越像MPP数据库了（并且能实现可与之媲美的性能）。同时，通过拥有运行任意代码和以任意格式读取数据的可扩展性，它们保持了灵活性的优势。
最终，它们都只是存储和处理数据的系统。
```