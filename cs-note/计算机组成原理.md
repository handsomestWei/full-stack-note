# 计算机组成原理
极客时间《深入浅出计算机组成原理》笔记

## 指令设计
### RISC和CISC
时间VS空间
+ 精简指令集：较少的门电路和寄存器，但更长的门延迟和时钟周期。对硬件分层封装，用门电路搭积木。
+ 复杂指令集：复杂的电路，但是更短的门延迟和时钟周期。对门电路展开成复杂电路，增加线路/硬件复杂度，空间换时间，但电路的晶体管数量增多，占用cpu的体积和增加功耗影响散热。

### 硬件分层封装设计
简化设计，像搭积木，提供了更多简单电路来支持更多的简单指令。
```
时钟周期：晶体振荡器
加法器：门电路->半加器->全加器->加法器->ALU
乘法器：多个ALU并行加速
```

### 指令周期
```
1）时钟周期，1/主频，时钟每一下对应xx秒。相当于门电路信号频率。
2）cpu周期，由多个时钟周期组成。从内存里面读一条指令最短时间，涉及多个寄存器，要经历多个门电路。
3）指令周期，由多个cpu周期组成。至少两部分：取指令，然后执行。
```
```
一个程序的CPU耗时=时钟周期xcpu时钟周期数
其中cpu时钟周期数=指令数×每条指令的平均时钟周期数cpi（Cycles Per Instruction）
提升性能的方式有：
1）提升时钟周期，但一般不变，1/主频，可以cpu超频。
2）优化cpi，流水线技术。
3）减少指令数，编译器优化。
```

### 单指令周期处理器
在一个时钟周期里，确保执行完一条最复杂的 CPU 指令，也就是耗时最长的一条 CPU 指令。
```
缺点:
浪费，指令都要去等待一些慢速的操作，不同指令执行速度有差异。即便只调用一条非常简单的指令，也需要等待整个时钟周期的时间走完，才能执行下一条指令。
```

### 指令流水线
不需要确保最复杂的那条指令在时钟周期里面执行完成，而只要保障一个最复杂的流水线级的操作，在一个时钟周期内完成。
```
优点：
虽然不能通过流水线，来减少单条指令执行的延时，但是通过同时在执行多条指令的不同阶段，提升了CPU的吞吐率。
```
```
超长流水线的性能瓶颈:
1）流水线结果要放入寄存器存取，增加读写开销。
2）电路和晶体管变多，增加功耗温度影响散热。
```

### 冒险
计算中的相互依赖问题，称之为计算机组成中的冒险问题。数据层面的依赖，就是数据冒险。还会有结构冒险、控制冒险等其他的依赖问题。
```
主动的进行冒险选择，期望能够通过冒险带来更高的回报。对于各种冒险可能造成的问题，准备好应对的方案。
```
#### 结构冒险
硬件层面的资源竞争。
```
例如典型的内存数据访问：
同一个时钟下对于相同资源的发生竞争。CPU在同一个时钟周期，同时在运行两条计算机指令的不同阶段，但是这两个不同的阶段，可能会用到同样的硬件电路。只能在一个时钟周期里执行一条指令。
```
```
解决方案：
堆资源
1）哈佛架构：对于访问内存数据和取指令的冲突，直观的解决方案是把内存分成两部分，让它们各有各的地址译码器，这两部分分别是存放指令的程序内存和存放数据的数据内存。但会失去内存动态分配的灵活性。
2）借鉴哈佛结构的一个混合结构：在冯诺依曼架构下，对CPU内部的高速缓存部分进行区分，把高速缓存分成了指令缓存（Instruction Cache）和数据缓存（Data Cache）两部分。CPU并不会直接读取主内存，它会从主内存把指令和数据加载到高速缓存中，这样后续的访问都是访问高速缓存。而指令缓存和数据缓存的拆分，使得我们的CPU在进行数据访问和取指令的时候，不会再发生资源冲突的问题。
```

#### 数据冒险
发生在程序逻辑层面，同时在执行的多个指令之间，有数据依赖的情况。
```
1）先写后读（Read After Write，RAW），称为数据依赖
2）先读后写（Write After Read，WAR），称为反依赖
3）写后再写（Write After Write，WAW），称为输出依赖
```
```
解决方案：
等排期
流水线停顿，也叫冒泡。在流水线上插入无效的NOP操作。但是以牺牲CPU性能为代价，在最差的情况下，流水线架构的CPU又会退化成单指令周期的CPU。
```

## 二进制
### 编码
```
信息转换，人类能看懂的信息转换为计算机能识别的信息。同一个字符集，可以有不同字符编码。
字符集：字符的集合，如ascii包含常用字符集，Unicode中文字符集。
字符编码规则：码表、字典规则。字符集里的每个字符，都对应一个二进制编码。
```

### 运算
#### 原反补码
```
01的三种表示形式：
1）最高位表示值。缺点是不能表示正负。
2）最高位表示符号。缺点是占用一位只表示正负，浪费一位。
3）最高位既表示值，也表示符号。这就是补码的形式。换算口诀是补码=原码的反码+末尾加一。例如100，最高位1说明是负数，且对应值为-1 * 2的2次方。
```
#### 溢出
```
运算后，超出位数的值舍弃。
```

#### 浮点数
```
1）浮点数不精确，例如0.3+0.6=0.89999而不是0.9
2）不精确的原因发生在浮点数的二进制转换，和整数的二进制转换类似。整数是累除2会有结束的时候，浮点数是累乘2所以会无限循环。例如0.1实际是0011无限循环的二进制小数，0.000110011...
3）浮点数加法要对齐大数的最高位，小数移位过程会丢失精度，累加时要使用补偿算法。
```

### 函数内联
编译器自动优化，也可以用关键字显式指定。
+ 优点：内联使cpu需要执行的指令数变少了，根据地址跳转的过程不需要了，压栈和出栈的过程也不用了。
+ 缺点：内联意味把可以复用的程序指令在调用它的地方完全展开。如果一个函数在很多地方都被调用了，那么就会展开很多次，整个程序占用的空间就会变大。